// This file was generated by counterfeiter
package fakes

import (
	"cf-cli-plugin/netapi"
	"sync"
)

type Client struct {
	AllowStub        func(rule netapi.Rule, token string) error
	allowMutex       sync.RWMutex
	allowArgsForCall []struct {
		rule  netapi.Rule
		token string
	}
	allowReturns struct {
		result1 error
	}
	DisallowStub        func(rule netapi.Rule, token string) error
	disallowMutex       sync.RWMutex
	disallowArgsForCall []struct {
		rule  netapi.Rule
		token string
	}
	disallowReturns struct {
		result1 error
	}
	ListStub        func(token string) ([]netapi.Rule, error)
	listMutex       sync.RWMutex
	listArgsForCall []struct {
		token string
	}
	listReturns struct {
		result1 []netapi.Rule
		result2 error
	}
	invocations map[string][][]interface{}
}

func (fake *Client) Allow(rule netapi.Rule, token string) error {
	fake.allowMutex.Lock()
	fake.allowArgsForCall = append(fake.allowArgsForCall, struct {
		rule  netapi.Rule
		token string
	}{rule, token})
	fake.guard("Allow")
	fake.invocations["Allow"] = append(fake.invocations["Allow"], []interface{}{rule, token})
	fake.allowMutex.Unlock()
	if fake.AllowStub != nil {
		return fake.AllowStub(rule, token)
	} else {
		return fake.allowReturns.result1
	}
}

func (fake *Client) AllowCallCount() int {
	fake.allowMutex.RLock()
	defer fake.allowMutex.RUnlock()
	return len(fake.allowArgsForCall)
}

func (fake *Client) AllowArgsForCall(i int) (netapi.Rule, string) {
	fake.allowMutex.RLock()
	defer fake.allowMutex.RUnlock()
	return fake.allowArgsForCall[i].rule, fake.allowArgsForCall[i].token
}

func (fake *Client) AllowReturns(result1 error) {
	fake.AllowStub = nil
	fake.allowReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) Disallow(rule netapi.Rule, token string) error {
	fake.disallowMutex.Lock()
	fake.disallowArgsForCall = append(fake.disallowArgsForCall, struct {
		rule  netapi.Rule
		token string
	}{rule, token})
	fake.guard("Disallow")
	fake.invocations["Disallow"] = append(fake.invocations["Disallow"], []interface{}{rule, token})
	fake.disallowMutex.Unlock()
	if fake.DisallowStub != nil {
		return fake.DisallowStub(rule, token)
	} else {
		return fake.disallowReturns.result1
	}
}

func (fake *Client) DisallowCallCount() int {
	fake.disallowMutex.RLock()
	defer fake.disallowMutex.RUnlock()
	return len(fake.disallowArgsForCall)
}

func (fake *Client) DisallowArgsForCall(i int) (netapi.Rule, string) {
	fake.disallowMutex.RLock()
	defer fake.disallowMutex.RUnlock()
	return fake.disallowArgsForCall[i].rule, fake.disallowArgsForCall[i].token
}

func (fake *Client) DisallowReturns(result1 error) {
	fake.DisallowStub = nil
	fake.disallowReturns = struct {
		result1 error
	}{result1}
}

func (fake *Client) List(token string) ([]netapi.Rule, error) {
	fake.listMutex.Lock()
	fake.listArgsForCall = append(fake.listArgsForCall, struct {
		token string
	}{token})
	fake.guard("List")
	fake.invocations["List"] = append(fake.invocations["List"], []interface{}{token})
	fake.listMutex.Unlock()
	if fake.ListStub != nil {
		return fake.ListStub(token)
	} else {
		return fake.listReturns.result1, fake.listReturns.result2
	}
}

func (fake *Client) ListCallCount() int {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return len(fake.listArgsForCall)
}

func (fake *Client) ListArgsForCall(i int) string {
	fake.listMutex.RLock()
	defer fake.listMutex.RUnlock()
	return fake.listArgsForCall[i].token
}

func (fake *Client) ListReturns(result1 []netapi.Rule, result2 error) {
	fake.ListStub = nil
	fake.listReturns = struct {
		result1 []netapi.Rule
		result2 error
	}{result1, result2}
}

func (fake *Client) Invocations() map[string][][]interface{} {
	return fake.invocations
}

func (fake *Client) guard(key string) {
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
}
